import basic;
auto scombinator(alias F,R,A...)(R r,A args){
	static A args_;
	args_=args;
	struct scomb(T){
		T me;
		auto get(){
			return F(me,args_);
		}
		alias get this;
		auto opDispatch(string name,T...)(T vals){
			mixin("return "~name~"(F(me,args),vals);");
		}
		auto ref unpack(){
			return me;
		}
	}
	return r.map!(a=>scomb!(typeof(a))(a));
}
unittest{
	[-3,2,-1,4,-5].scombinator!(a=>a*a).array.sort.map!(a=>a.unpack).writeln;
	"aZzA,Hello, World".scombinator!toLower.array.sort.map!(a=>a.unpack).writeln;
	iota(1,10).scombinator!(iota)(10).map!((a){a.writeln; return a;}).map!(a=>a.unpack).writeln;
	//"hi,foo,(bar,faz,bye),hello,((world))"
	//	.scombinator!(cumulativeFold!(
	//		a=>
	//			a+
	//			(a.me=='(')*-1+
	//			(a.me==')')*1
	//	))
}
import std.traits;
auto accmap(alias F,R,A...)(R r,A args){
	struct accmap_{
		R r;
		static assert(is(A==Parameters!F[1..$]),"matchs the args");
		A args;
		alias T=typeof(F(r.front,args));
		T store;
		bool write=false;
		T front(){
			if(!write){
				store=F(r.front,args);
				write=true;
			}
			return store;
		}
		void popFront(){
			r.popFront;
			write=false;
		}
		bool empty(){
			return r.empty;
		}
	}
	return accmap_(r,args);
}
unittest{
	static bool markcommas(dchar c,ref int para,ref bool quote){
		if(c=='"'){quote = ! quote;}
		if(c=='('){para++;}
		if(c==')'){para--;}
		if(c==','&& para==0 && !quote){return true;}
		return false;
	}
	"hi,foo,(bar,faz,bye),hello,((world)),\",,,,,\"".writeln;
	"hi,foo,(bar,faz,bye),hello,((world)),\",,,,,\"".accmap!markcommas(0,false).map!(a=>a?'0':'1').writeln;
}